import pytest
from dijkstra import dijkstra_shortest_path
import math

def check_distances(actual, expected):
    """Helper to compare distance dictionaries, handling float('inf')."""
    assert set(actual.keys()) == set(expected.keys()), "Node sets mismatch"

    for node in expected:
        expected_dist = expected[node]
        actual_dist = actual[node]

        if math.isinf(expected_dist):
            assert math.isinf(actual_dist), f"Node {node}: Expected inf, got {actual_dist}"
        else:
            # Using exact comparison for non-inf distances generated by integer weights
            if expected_dist != actual_dist:
                pytest.fail(f"Node {node}: Expected {expected_dist}, Got {actual_dist}")


def test_dijkstra_basic_path():
    # Test Case 1: Standard Acyclic Graph
    graph = {
        'A': [('B', 1), ('C', 4)],
        'B': [('C', 2), ('D', 5)],
        'C': [('D', 1)],
        'D': []
    }
    start_node = 'A'
    expected = {'A': 0, 'B': 1, 'C': 3, 'D': 4}

    result = dijkstra_shortest_path(graph, start_node)
    check_distances(result, expected)


def test_dijkstra_with_unreachable_nodes():
    # Test Case 2: Disconnected Graph, ensuring unreachable nodes are infinity
    inf = float('inf')
    graph = {
        1: [(2, 10)],
        2: [],
        3: [(4, 1)],
        4: []
    }
    start_node = 1
    expected = {1: 0, 2: 10, 3: inf, 4: inf}

    result = dijkstra_shortest_path(graph, start_node)
    check_distances(result, expected)


def test_dijkstra_single_node():
    # Test Case 3: Graph with only one node
    graph = {'A': []}
    start_node = 'A'
    expected = {'A': 0}

    result = dijkstra_shortest_path(graph, start_node)
    check_distances(result, expected)


def test_dijkstra_complex_network():
    # Test Case 4: Complex path finding involving multiple routes
    graph = {
        0: [(1, 4), (7, 1)],
        1: [(2, 2), (7, 2)],
        2: [(5, 3), (3, 5)],
        3: [(4, 6)],
        4: [(5, 1)],
        5: [(6, 2)],
        6: [(5, 1)],
        7: [(8, 3), (6, 8)],
        8: [(6, 1)]
    }
    start_node = 0
    expected = {0: 0, 1: 4, 2: 6, 3: 11, 4: 17, 5: 7, 6: 5, 7: 1, 8: 4}

    result = dijkstra_shortest_path(graph, start_node)
    check_distances(result, expected)


def test_dijkstra_zero_weight_edges():
    # Test Case 5: Graph including zero weight edges
    graph = {
        'X': [('Y', 0), ('Z', 10)],
        'Y': [('Z', 5)],
        'Z': []
    }
    start_node = 'X'
    expected = {'X': 0, 'Y': 0, 'Z': 5}

    result = dijkstra_shortest_path(graph, start_node)
    check_distances(result, expected)


def test_dijkstra_isolated_start_node():
    # Test Case 6: Start node is defined but isolated from paths leading to other nodes.
    inf = float('inf')
    graph = {
        'A': [( 'B', 1)],
        'B': [],
        'C': [] 
    }
    start_node = 'C'
    expected = {'A': inf, 'B': inf, 'C': 0}

    result = dijkstra_shortest_path(graph, start_node)
    check_distances(result, expected)


def test_dijkstra_no_edges():
    # Test Case 7: Graph with multiple nodes but no edges
    inf = float('inf')
    graph = {
        'N1': [],
        'N2': [],
        'N3': []
    }
    start_node = 'N2'
    expected = {'N1': inf, 'N2': 0, 'N3': inf}

    result = dijkstra_shortest_path(graph, start_node)
    check_distances(result, expected)
